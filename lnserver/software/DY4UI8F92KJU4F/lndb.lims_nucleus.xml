<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<database name="lndb" schema="lims_nucleus" type="PostgreSQL - 10.5 (Debian 10.5-1)">
   <tables>
      <table name="assay_result" numRows="384" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="assay_run_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_result_assay_run_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="assay_run"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="plate_order" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="well" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="8" id="3" name="response" nullable="true" remarks="" size="8" type="float4"/>
         <column autoUpdated="false" digits="8" id="4" name="bkgrnd_sub" nullable="true" remarks="" size="8" type="float4"/>
         <column autoUpdated="false" digits="8" id="5" name="norm" nullable="true" remarks="" size="8" type="float4"/>
         <column autoUpdated="false" digits="8" id="6" name="norm_pos" nullable="true" remarks="" size="8" type="float4"/>
         <column autoUpdated="false" digits="8" id="7" name="p_enhance" nullable="true" remarks="" size="8" type="float4"/>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="8" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <index name="assay_result_assay_run_id_idx" unique="false">
            <column ascending="true" name="assay_run_id"/>
         </index>
         <index name="assay_result_plate_order_idx" unique="false">
            <column ascending="true" name="plate_order"/>
         </index>
         <index name="assay_result_well_idx" unique="false">
            <column ascending="true" name="well"/>
         </index>
      </table>
      <table name="assay_result_pre" numRows="192" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="assay_run_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_result_pre_assay_run_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="plate_order" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="well" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="8" id="3" name="response" nullable="true" remarks="" size="8" type="float4"/>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="4" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
      </table>
      <table name="assay_run" numRows="5" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('assay_run_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="assay_run_id" foreignKey="assay_result_assay_run_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="assay_result"/>
            <child column="assay_run_id" foreignKey="assay_result_pre_assay_run_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_result_pre"/>
            <child column="assay_run_id" foreignKey="assay_run_stats_assay_run_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run_stats"/>
            <child column="assay_run_id" foreignKey="hit_list_assay_run_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="hit_list"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="assay_run_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="assay_run_name" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="descr" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="assay_type_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_run_assay_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_type"/>
         </column>
         <column autoUpdated="false" digits="0" id="5" name="plate_set_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_run_plate_set_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_set"/>
         </column>
         <column autoUpdated="false" digits="0" id="6" name="plate_layout_name_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_run_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout_name"/>
         </column>
         <column autoUpdated="false" digits="0" id="7" name="lnsession_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_run_lnsession_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="lnsession"/>
         </column>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="8" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="assay_run_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="assay_run_assay_type_id_idx" unique="false">
            <column ascending="true" name="assay_type_id"/>
         </index>
         <index name="assay_run_lnsession_id_idx" unique="false">
            <column ascending="true" name="lnsession_id"/>
         </index>
         <index name="assay_run_plate_layout_name_id_idx" unique="false">
            <column ascending="true" name="plate_layout_name_id"/>
         </index>
         <index name="assay_run_plate_set_id_idx" unique="false">
            <column ascending="true" name="plate_set_id"/>
         </index>
      </table>
      <table name="assay_run_stats" numRows="8" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="assay_run_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="assay_run_stats_assay_run_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="response_type" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="max_response" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="3" name="min_response" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="4" name="mean_bkgrnd" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="5" name="std_dev_bkgrnd" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="6" name="mean_pos" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="7" name="stdev_pos" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="8" name="mean_neg_3_sd" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="9" name="mean_neg_2_sd" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="10" name="mean_pos_3_sd" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" digits="0" id="11" name="mean_pos_2_sd" nullable="true" remarks="" size="131089" type="numeric"/>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="12" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <index name="assay_run_stats_assay_run_id_idx" unique="false">
            <column ascending="true" name="assay_run_id"/>
         </index>
      </table>
      <table name="assay_type" numRows="6" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('assay_type_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="assay_type_id" foreignKey="assay_run_assay_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="assay_type_name" nullable="true" remarks="" size="250" type="varchar"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="assay_type_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="hit_list" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('hit_list_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="hitlist_id" foreignKey="hit_sample_hitlist_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="hit_sample"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="hitlist_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="hitlist_name" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="descr" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="n" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="5" name="lnsession_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="hit_list_lnsession_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="lnsession"/>
         </column>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="6" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <column autoUpdated="false" digits="0" id="7" name="assay_run_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="hit_list_assay_run_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="assay_run"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="hit_list_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="hit_list_assay_run_id_idx" unique="false">
            <column ascending="true" name="assay_run_id"/>
         </index>
         <index name="hit_list_lnsession_id_idx" unique="false">
            <column ascending="true" name="lnsession_id"/>
         </index>
      </table>
      <table name="hit_sample" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="hitlist_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="hit_sample_hitlist_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="hit_list"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="sample_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="hit_sample_sample_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="sample"/>
         </column>
         <index name="hit_sample_hitlist_id_idx" unique="false">
            <column ascending="true" name="hitlist_id"/>
         </index>
         <index name="hit_sample_sample_id_idx" unique="false">
            <column ascending="true" name="sample_id"/>
         </index>
      </table>
      <table name="import_plate_layout" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="plate_layout_name_id" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="1" name="well_by_col" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="well_type_id" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="3" name="replicates" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="4" name="target" nullable="true" remarks="" size="10" type="int4"/>
      </table>
      <table name="layout_source_dest" numRows="34" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="src" nullable="false" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="1" name="dest" nullable="false" remarks="" size="10" type="int4"/>
      </table>
      <table name="lnsession" numRows="2" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('lnsession_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="lnsession_id" foreignKey="assay_run_lnsession_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run"/>
            <child column="lnsession_id" foreignKey="hit_list_lnsession_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="hit_list"/>
            <child column="lnsession_id" foreignKey="plate_set_lnsession_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate_set"/>
            <child column="lnsession_id" foreignKey="project_lnsession_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="project"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="lnuser_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="lnsession_lnuser_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="lnuser"/>
         </column>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="2" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="lnsession_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="lnuser" numRows="2" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('lnuser_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="lnuser_id" foreignKey="lnsession_lnuser_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="lnsession"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="usergroup_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="lnuser_usergroup_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="lnuser_groups"/>
         </column>
         <column autoUpdated="false" digits="0" id="2" name="lnuser_name" nullable="false" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="tags" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="password" nullable="false" remarks="" size="64" type="varchar"/>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="5" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="lnuser_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="lnuser_lnuser_name_key" unique="true">
            <column ascending="true" name="lnuser_name"/>
         </index>
      </table>
      <table name="lnuser_groups" numRows="2" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('lnuser_groups_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="usergroup_id" foreignKey="lnuser_usergroup_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="lnuser"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="usergroup" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="2" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="lnuser_groups_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="plate" numRows="29" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('plate_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="plate_id" foreignKey="plate_plate_set_plate_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate_plate_set"/>
            <child column="plate_id" foreignKey="well_plate_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="well"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="barcode" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="plate_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="plate_type_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_plate_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_type"/>
         </column>
         <column autoUpdated="false" digits="0" id="4" name="plate_format_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_plate_format_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_format"/>
         </column>
         <column autoUpdated="false" digits="0" id="5" name="plate_layout_name_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout_name"/>
         </column>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="6" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="plate_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="plate_barcode_idx" unique="false">
            <column ascending="true" name="barcode"/>
         </index>
         <index name="plate_plate_format_id_idx" unique="false">
            <column ascending="true" name="plate_format_id"/>
         </index>
         <index name="plate_plate_type_id_idx" unique="false">
            <column ascending="true" name="plate_type_id"/>
         </index>
      </table>
      <table name="plate_format" numRows="3" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4">
            <child column="plate_format_id" foreignKey="plate_plate_format_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate"/>
            <child column="plate_format_id" foreignKey="plate_layout_name_plate_format_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout_name"/>
            <child column="plate_format_id" foreignKey="plate_set_plate_format_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_set"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="format" nullable="true" remarks="" size="6" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="rownum" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="3" name="colnum" nullable="true" remarks="" size="10" type="int4"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="plate_format_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="plate_layout" numRows="43968" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="plate_layout_name_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_layout_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout_name"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="well_by_col" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="well_type_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_layout_well_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="well_type"/>
         </column>
         <column autoUpdated="false" digits="0" id="3" name="replicates" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="4" name="target" nullable="true" remarks="" size="10" type="int4"/>
         <index name="plate_layout_plate_layout_name_id_idx" unique="false">
            <column ascending="true" name="plate_layout_name_id"/>
         </index>
         <index name="plate_layout_well_by_col_idx" unique="false">
            <column ascending="true" name="well_by_col"/>
         </index>
         <index name="plate_layout_well_type_id_idx" unique="false">
            <column ascending="true" name="well_type_id"/>
         </index>
      </table>
      <table name="plate_layout_name" numRows="41" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('plate_layout_name_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="plate_layout_name_id" foreignKey="assay_run_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run"/>
            <child column="plate_layout_name_id" foreignKey="plate_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate"/>
            <child column="plate_layout_name_id" foreignKey="plate_layout_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout"/>
            <child column="plate_layout_name_id" foreignKey="plate_set_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_set"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="name" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="descr" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="plate_format_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_layout_name_plate_format_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_format"/>
         </column>
         <column autoUpdated="false" digits="0" id="5" name="replicates" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="6" name="targets" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="7" name="use_edge" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="8" name="num_controls" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="9" name="unknown_n" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="10" name="control_loc" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="11" name="source_dest" nullable="true" remarks="" size="30" type="varchar"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="plate_layout_name_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="plate_layout_name_plate_format_id_idx" unique="false">
            <column ascending="true" name="plate_format_id"/>
         </index>
      </table>
      <table name="plate_plate_set" numRows="29" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="plate_set_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_plate_set_plate_set_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate_set"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="plate_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_plate_set_plate_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate"/>
         </column>
         <column autoUpdated="false" digits="0" id="2" name="plate_order" nullable="true" remarks="" size="10" type="int4"/>
         <index name="plate_plate_set_plate_id_idx" unique="false">
            <column ascending="true" name="plate_id"/>
         </index>
         <index name="plate_plate_set_plate_set_id_idx" unique="false">
            <column ascending="true" name="plate_set_id"/>
         </index>
      </table>
      <table name="plate_set" numRows="7" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('plate_set_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="plate_set_id" foreignKey="assay_run_plate_set_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="assay_run"/>
            <child column="plate_set_id" foreignKey="plate_plate_set_plate_set_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate_plate_set"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="plate_set_name" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="descr" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="plate_set_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="num_plates" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="5" name="plate_format_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_set_plate_format_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_format"/>
         </column>
         <column autoUpdated="false" digits="0" id="6" name="plate_type_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_set_plate_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_type"/>
         </column>
         <column autoUpdated="false" digits="0" id="7" name="project_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_set_project_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="project"/>
         </column>
         <column autoUpdated="false" digits="0" id="8" name="plate_layout_name_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_set_plate_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout_name"/>
         </column>
         <column autoUpdated="false" digits="0" id="9" name="lnsession_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_set_lnsession_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="lnsession"/>
         </column>
         <column autoUpdated="false" digits="0" id="10" name="target_layout_name_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="plate_set_target_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target_layout_name"/>
         </column>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="11" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="plate_set_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="plate_set_lnsession_id_idx" unique="false">
            <column ascending="true" name="lnsession_id"/>
         </index>
         <index name="plate_set_plate_format_id_idx" unique="false">
            <column ascending="true" name="plate_format_id"/>
         </index>
         <index name="plate_set_plate_layout_name_id_idx" unique="false">
            <column ascending="true" name="plate_layout_name_id"/>
         </index>
         <index name="plate_set_plate_type_id_idx" unique="false">
            <column ascending="true" name="plate_type_id"/>
         </index>
         <index name="plate_set_project_id_idx" unique="false">
            <column ascending="true" name="project_id"/>
         </index>
         <index name="plate_set_target_layout_name_id_idx" unique="false">
            <column ascending="true" name="target_layout_name_id"/>
         </index>
      </table>
      <table name="plate_type" numRows="6" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('plate_type_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="plate_type_id" foreignKey="plate_plate_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate"/>
            <child column="plate_type_id" foreignKey="plate_set_plate_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_set"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="plate_type_name" nullable="true" remarks="" size="30" type="varchar"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="plate_type_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="project" numRows="10" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('project_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="project_id" foreignKey="plate_set_project_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate_set"/>
            <child column="project_id" foreignKey="sample_project_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="sample"/>
            <child column="project_id" foreignKey="target_project_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target"/>
            <child column="project_id" foreignKey="target_layout_name_project_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target_layout_name"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="project_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="descr" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="project_name" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="lnsession_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="project_lnsession_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="lnsession"/>
         </column>
         <column autoUpdated="false" defaultValue="CURRENT_TIMESTAMP" digits="6" id="5" name="updated" nullable="false" remarks="" size="35" type="timestamptz"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="project_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="project_lnsession_id_idx" unique="false">
            <column ascending="true" name="lnsession_id"/>
         </index>
      </table>
      <table name="rearray_pairs" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('rearray_pairs_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="rearray_pairs_id" foreignKey="worklists_rearray_pairs_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="worklists"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="src" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="dest" nullable="true" remarks="" size="10" type="int4"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="rearray_pairs_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="rearray_pairs_dest_idx" unique="false">
            <column ascending="true" name="dest"/>
         </index>
         <index name="rearray_pairs_src_idx" unique="false">
            <column ascending="true" name="src"/>
         </index>
      </table>
      <table name="sample" numRows="4648" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('sample_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="sample_id" foreignKey="hit_sample_sample_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="hit_sample"/>
            <child column="sample_id" foreignKey="well_sample_sample_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="well_sample"/>
            <child column="sample_id" foreignKey="worklists_sample_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="worklists"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="sample_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="project_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="sample_project_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="project"/>
         </column>
         <column autoUpdated="false" digits="0" id="3" name="accs_id" nullable="true" remarks="" size="30" type="varchar"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="sample_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="sample_project_id_idx" unique="false">
            <column ascending="true" name="project_id"/>
         </index>
      </table>
      <table name="target" numRows="12" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('target_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="target_id" foreignKey="target_layout_target_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target_layout"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="target_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="project_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="target_project_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="project"/>
         </column>
         <column autoUpdated="false" digits="0" id="3" name="target_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="descr" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="5" name="accs_id" nullable="true" remarks="" size="30" type="varchar"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="target_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="target_layout" numRows="12" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="target_layout_name_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="target_layout_target_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target_layout_name"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="target_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="target_layout_target_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target"/>
         </column>
         <column autoUpdated="false" digits="0" id="2" name="quad" nullable="true" remarks="" size="10" type="int4"/>
         <index name="target_layout_target_layout_name_id_idx" unique="false">
            <column ascending="true" name="target_layout_name_id"/>
         </index>
      </table>
      <table name="target_layout_name" numRows="3" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('target_layout_name_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="target_layout_name_id" foreignKey="plate_set_target_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_set"/>
            <child column="target_layout_name_id" foreignKey="target_layout_target_layout_name_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="target_layout"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="project_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="target_layout_name_project_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="project"/>
         </column>
         <column autoUpdated="false" digits="0" id="2" name="target_layout_name_sys_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="target_layout_name_name" nullable="true" remarks="" size="30" type="varchar"/>
         <column autoUpdated="false" digits="0" id="4" name="target_layout_name_desc" nullable="true" remarks="" size="250" type="varchar"/>
         <column autoUpdated="false" digits="0" id="5" name="reps" nullable="true" remarks="" size="10" type="int4"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="target_layout_name_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="temp_accs_id" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="plate_order" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="1" name="by_col" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="accs_id" nullable="true" remarks="" size="30" type="varchar"/>
         <index name="temp_accs_id_by_col_idx" unique="false">
            <column ascending="true" name="by_col"/>
         </index>
         <index name="temp_accs_id_plate_order_idx" unique="false">
            <column ascending="true" name="plate_order"/>
         </index>
      </table>
      <table name="temp_barcode_id" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="plate_order" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="1" name="barcode_id" nullable="true" remarks="" size="30" type="varchar"/>
         <index name="temp_barcode_id_plate_order_idx" unique="false">
            <column ascending="true" name="plate_order"/>
         </index>
      </table>
      <table name="well" numRows="4800" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('well_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="well_id" foreignKey="well_sample_well_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="well_sample"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="by_col" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="2" name="plate_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="well_plate_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="plate"/>
         </column>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="well_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="well_plate_id_idx" unique="false">
            <column ascending="true" name="plate_id"/>
         </index>
      </table>
      <table name="well_numbers" numRows="2016" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="plate_format" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="1" name="well_name" nullable="true" remarks="" size="5" type="varchar"/>
         <column autoUpdated="false" digits="0" id="2" name="row" nullable="true" remarks="" size="2" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="row_num" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="4" name="col" nullable="true" remarks="" size="2" type="varchar"/>
         <column autoUpdated="false" digits="0" id="5" name="total_col_count" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="6" name="by_row" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="7" name="by_col" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="8" name="quad" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="9" name="parent_well" nullable="true" remarks="" size="10" type="int4"/>
         <index name="well_numbers_by_col_idx" unique="false">
            <column ascending="true" name="by_col"/>
         </index>
      </table>
      <table name="well_sample" numRows="4648" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="well_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="well_sample_well_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="well"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="sample_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="well_sample_sample_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="sample"/>
         </column>
         <index name="well_sample_sample_id_idx" unique="false">
            <column ascending="true" name="sample_id"/>
         </index>
         <index name="well_sample_well_id_idx" unique="false">
            <column ascending="true" name="well_id"/>
         </index>
      </table>
      <table name="well_type" numRows="5" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('well_type_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial">
            <child column="well_type_id" foreignKey="plate_layout_well_type_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="plate_layout"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="name" nullable="true" remarks="" size="30" type="varchar"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="well_type_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
      </table>
      <table name="worklists" numRows="0" remarks="" schema="lims_nucleus" type="TABLE">
         <column autoUpdated="false" digits="0" id="0" name="rearray_pairs_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="worklists_rearray_pairs_id_fkey" implied="false" onDeleteCascade="true" schema="lims_nucleus" table="rearray_pairs"/>
         </column>
         <column autoUpdated="false" digits="0" id="1" name="sample_id" nullable="true" remarks="" size="10" type="int4">
            <parent column="id" foreignKey="worklists_sample_id_fkey" implied="false" onDeleteCascade="false" schema="lims_nucleus" table="sample"/>
         </column>
         <column autoUpdated="false" digits="0" id="2" name="source_plate" nullable="true" remarks="" size="10" type="varchar"/>
         <column autoUpdated="false" digits="0" id="3" name="source_well" nullable="true" remarks="" size="10" type="int4"/>
         <column autoUpdated="false" digits="0" id="4" name="dest_plate" nullable="true" remarks="" size="10" type="varchar"/>
         <column autoUpdated="false" digits="0" id="5" name="dest_well" nullable="true" remarks="" size="10" type="int4"/>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_contained" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[contained in]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_contained_joinsel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_contained_sel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_contains" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[contains]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_contains_joinsel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_contains_sel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_different" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[different]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_inter" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_matchsel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_overlap" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[overlaps]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_overlap_joinsel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="_int_overlap_sel" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_same" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[same as]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_int_union" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_intbig_in" returnType="intbig_gkey" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_intbig_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="armor" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="assoc_plate_ids_with_plate_set_id" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   pid int;
   plate_ids int[];
   counter INTEGER;
   sql_statement VARCHAR;
   
BEGIN
counter := 1;
SELECT sort(_plate_ids) INTO plate_ids;
sql_statement := 'INSERT INTO plate_plate_set (plate_set_id, plate_id, plate_order) VALUES ';

  FOREACH pid IN ARRAY plate_ids
     LOOP
     sql_statement := sql_statement || '(' || _plate_set_id || ', '  ||  pid || ', ' || counter || '),';
     counter = counter + 1;
    END LOOP;

     sql_statement := SUBSTRING(sql_statement, 1, CHAR_LENGTH(sql_statement)-1) || ';';
     --RAISE notice 'sqlstatement: (%)', sql_statement;
     EXECUTE sql_statement;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="boolop" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[boolean operation with array]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="bqarr_in" returnType="query_int" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="bqarr_out" returnType="cstring" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bulk_target_upload" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   m text[];
BEGIN
   FOREACH m SLICE 1 IN ARRAY _fields
   LOOP
         PERFORM new_target( CAST(m[1] AS INTEGER), m[2], m[3], m[4]);
--      RAISE NOTICE '% EXECUTING fieldname: %, stats: %', now()::text, m[1], m[2];
   END LOOP;
END
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="calc_by_row_num_func" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[

BEGIN
 NEW.by_row := NEW.total_col_count*(NEW.row_num -1) + CAST(NEW.col AS integer);
 IF  (CAST(NEW.col AS INTEGER)%2 = 1) AND ( NEW.row_num%2 = 1)  THEN
    NEW.quad :=1;
    elsif (CAST(NEW.col AS INTEGER)%2 = 0) AND ( NEW.row_num%2 = 1)  THEN
    NEW.quad :=2;
    ELSIF (CAST(NEW.col AS INTEGER)%2 = 1) AND ( NEW.row_num%2 = 0)  THEN
    NEW.quad :=3;
    ELSE
    NEW.quad :=4;
    END IF;
    
 RETURN NEW;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_layout_records" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   source_id INTEGER;
   dest_id INTEGER;
   edge INTEGER;
dest_layout_ids INTEGER[];
dest_layout_descr VARCHAR[] := '{\"1S4T\",\"2S2T\",\"2S4T\",\"4S1T\",\"4S2T\"}';
dest_format INTEGER;
i INTEGER;

BEGIN

IF n_edge >0 THEN edge = 0; ELSE edge = 1; END IF;

IF format = 96 THEN
dest_layout_ids := '{2,3,4,5,6}';
dest_format := 384;
END IF;

IF format = 384 THEN
dest_layout_ids := '{14,15,16,17,18}';
dest_format := 1536;
END IF;

INSERT INTO plate_layout_name (NAME, descr, plate_format_id, replicates, targets, use_edge, num_controls, unknown_n, control_loc, source_dest) VALUES (source_name, source_description, format, 1, 1, edge, n_controls, n_unknowns, control_location, 'source') RETURNING ID INTO source_id;

    UPDATE plate_layout_name SET sys_name = 'LYT-'|| source_id WHERE id=source_id;

--insert source
INSERT INTO plate_layout (SELECT source_id AS "plate_layout_name_id", well_by_col, well_type_id, replicates, target FROM import_plate_layout); 


--insert destinations
FOR i IN 1..5 loop
INSERT INTO plate_layout_name ( descr, plate_format_id, replicates, targets, use_edge, num_controls, unknown_n, control_loc, source_dest) VALUES ( dest_layout_descr[i], dest_format, 1, 1, edge, n_controls, n_unknowns, control_location, 'dest') RETURNING ID INTO dest_id;
 UPDATE plate_layout_name SET sys_name = 'LYT-'|| dest_id WHERE id=dest_id;

INSERT INTO plate_layout (SELECT dest_id AS "plate_layout_name_id", well_numbers.by_col AS "well_by_col", import_plate_layout.well_type_id, plate_layout.replicates, plate_layout.target FROM well_numbers, import_plate_layout, plate_layout WHERE well_numbers.plate_format = dest_format AND import_plate_layout.well_by_col=well_numbers.parent_well AND plate_layout.plate_layout_name_id=dest_layout_ids[i] AND plate_layout.well_by_col=well_numbers.by_col);


INSERT INTO layout_source_dest (src, dest) VALUES (source_id, dest_id);
END LOOP;
--


TRUNCATE TABLE import_plate_layout;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="crypt" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="dearmor" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="decrypt" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="decrypt_iv" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="delete_neg_response" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN

NEW.response= GREATEST(NEW.response,0);

 RETURN NEW;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="digest" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="encrypt" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="encrypt_iv" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_compress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_consistent" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_decompress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_penalty" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_picksplit" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_same" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_int_union" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_compress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_consistent" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_decompress" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_penalty" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_picksplit" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_same" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="g_intbig_union" returnType="intbig_gkey" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_random_bytes" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_random_uuid" returnType="uuid" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_salt" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_all_data_for_assay_run" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE

v_assay_run_id INTEGER := _assay_run_id;
v_plate_set_id INTEGER;
v_plate_format INTEGER;
v_layout_id INTEGER;

BEGIN

SELECT assay_run.plate_set_id FROM assay_run WHERE assay_run.ID =v_assay_run_id INTO v_plate_set_id;
SELECT plate_layout_name.plate_format_id FROM plate_layout_name, assay_run WHERE plate_layout_name.ID= assay_run.plate_layout_name_id AND assay_run.ID =v_assay_run_id INTO v_plate_format;
SELECT assay_run.plate_layout_name_id FROM assay_run WHERE assay_run.ID =v_assay_run_id INTO v_layout_id;

--get the plate set
CREATE TEMP TABLE plate_set_data(assay_run_sys_name VARCHAR, plate_set_sys_name VARCHAR, plate_sys_name VARCHAR, plate_order INT, well_name VARCHAR, type_well VARCHAR, by_col INT, well_id INT, response REAL, bkgrnd_sub REAL, norm REAL, norm_pos REAL, p_enhance REAL, target_name varchar, target_accs VARCHAR );

INSERT INTO plate_set_data SELECT assay_run.assay_run_sys_name, plate_set.plate_set_sys_name , plate.plate_sys_name, plate_plate_set.plate_order, well_numbers.well_name, well_type.name, well.by_col, well.ID AS "well_id", assay_result.response, assay_result.bkgrnd_sub, assay_result.norm, assay_result.norm_pos, assay_result.p_enhance,  target.target_name, target.accs_id  FROM  plate_set, plate_plate_set, plate, well, assay_result, assay_run, well_numbers, plate_layout, well_type, target, target_layout_name, target_layout WHERE plate_plate_set.plate_set_id=plate_set.id AND plate_plate_set.plate_id=plate.ID and plate.id=well.plate_id  AND plate_set.ID = v_plate_set_id AND assay_result.assay_run_id= v_assay_run_id AND assay_result.plate_order=plate_plate_set.plate_order AND assay_result.well=well.by_col AND assay_run.ID = v_assay_run_id AND well_numbers.plate_format= v_plate_format AND well_numbers.by_col=well.by_col AND plate_layout.plate_layout_name_id=v_layout_id AND plate_layout.well_type_id=well_type.ID AND plate_layout.well_by_col=well.by_col AND well_numbers.quad=target_layout.quad and plate_set.target_layout_name_id=target_layout.target_layout_name_id and target_layout.target_id = target.id AND target_layout_name.id=target_layout.target_layout_name_id ;

CREATE TEMP TABLE sample_names(well_id INT, sample_sys_name VARCHAR, accs_id VARCHAR);

INSERT INTO sample_names SELECT well.ID AS "well_id", sample.sample_sys_name, sample.accs_id  FROM well, well_sample, sample WHERE well_sample.sample_id=sample.ID AND well_sample.well_id=well.ID AND well.ID IN (SELECT well.ID FROM  plate_plate_set, plate, well WHERE plate_plate_set.plate_id = plate.ID AND well.plate_id = plate.ID AND plate_plate_set.plate_set_id = v_plate_set_id);

RETURN query
  SELECT  plate_set_data.assay_run_sys_name,  plate_set_data.plate_set_sys_name, plate_set_data.plate_sys_name, plate_set_data.plate_order, plate_set_data.well_name, plate_set_data.type_well ,  plate_set_data.by_col, plate_set_data.response, plate_set_data.bkgrnd_sub, plate_set_data.norm, plate_set_data.norm_pos, plate_set_data.p_enhance, sample_names.sample_sys_name, sample_names.accs_id, plate_set_data.target_name, plate_set_data.target_accs FROM plate_set_data LEFT JOIN sample_names on (plate_set_data.well_id=sample_names.well_id) ORDER BY plate_set_data.plate_order desc, plate_set_data.by_col DESC;

DROP TABLE plate_set_data;
DROP TABLE sample_names;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_ids_for_sys_names" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   sn varchar(20);
   an_int integer;
   sys_ids INTEGER[];
   sql_statement VARCHAR;
   sql_statement2 VARCHAR;
   
   temp INTEGER;

BEGIN

 sql_statement := 'SELECT id FROM ' || _table || ' WHERE ' || _sys_name   || ' = ';

  FOREACH sn IN ARRAY _sys_names
     LOOP
     sql_statement2 := sql_statement || quote_literal(sn);
     EXECUTE sql_statement2 INTO temp;
     sys_ids := array_append(sys_ids, temp );
    END LOOP;

RETURN sys_ids;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_layout_id_for_plate_set_sys_name" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   v_id integer;
BEGIN
 SELECT plate_layout_name_id FROM plate_set WHERE plate_set_sys_name = _plate_set_sys_name into v_id;
RETURN v_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_layout_name_descr_for_layout_id" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
    r record;
   result VARCHAR(250);
BEGIN
SELECT plate_layout_name.name, plate_layout_name.descr FROM  plate_layout_name WHERE plate_layout_name.id = _plate_layout_id into r;
result := r.name || ';' || r.descr;
RETURN result;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_num_samples_for_plate_set" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   psid int := _plate_set_id;
   
   counter INTEGER;
   sql_statement VARCHAR;
all_sample_ids INTEGER[];
num_samples INTEGER;
   
BEGIN
sql_statement := 'SELECT ARRAY(SELECT sample.id FROM plate, plate_plate_set, well, sample, well_sample WHERE plate_plate_set.plate_set_id = ' || psid || ' AND plate_plate_set.plate_id = plate.id AND well.plate_id = plate.id AND well_sample.well_id = well.id AND well_sample.sample_id = sample.id ORDER BY plate_plate_set.plate_id, plate_plate_set.plate_order, well.id)';

--    RAISE notice 'sql_statement: (%)', sql_statement;

     EXECUTE sql_statement INTO all_sample_ids;
     num_samples := array_length(all_sample_ids ,1); 
 -- RAISE notice 'ids: (%)', all_sample_ids;
 -- RAISE notice 'num: (%)', num_samples;

RETURN num_samples;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_number_samples_for_psid" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   num_samples INTEGER;
   sql_statement VARCHAR;
  --plate_layout_name_id INTEGER;

BEGIN

     --sql_statement := 'SELECT plate_layout_name_id FROM plate_set WHERE id = ' || _psid;
     --EXECUTE sql_statement INTO plate_layout_name_id;

      sql_statement := 'SELECT count(sample_id) FROM well_sample WHERE well_sample.well_id IN (SELECT well.id FROM well WHERE well.plate_id  IN (SELECT plate_id FROM plate_plate_set WHERE plate_plate_set.plate_set_id = ' || _psid || '))'; 
      EXECUTE sql_statement INTO num_samples;

RETURN num_samples;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="get_scatter_plot_data" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
begin

CREATE TEMPORARY TABLE temp1 AS (SELECT  assay_result.plate_order,assay_result.well, assay_result.response, assay_result.bkgrnd_sub, assay_result.norm, assay_result.norm_pos, assay_result.p_enhance, assay_run.plate_set_id, assay_run.plate_layout_name_id, plate_layout.well_type_id, plate_layout.replicates, plate_layout.target FROM assay_run, assay_result JOIN plate_layout ON ( assay_result.well = plate_layout.well_by_col) WHERE assay_result.assay_run_id = assay_run.id  AND assay_run.ID = _assay_run_id AND plate_layout.plate_layout_name_id = assay_run.plate_layout_name_id);


CREATE TEMPORARY TABLE temp2 AS (SELECT plate_plate_set.plate_order, well.by_col, well_sample.sample_id FROM  plate_plate_set, plate_set, plate,  well,  well_sample, assay_run, sample WHERE plate_plate_set.plate_set_id = plate_set.ID AND plate_plate_set.plate_id = plate.ID AND well.plate_id = plate.id  and well_sample.well_id=well.ID AND well_sample.sample_id=sample.id AND plate_plate_set.plate_set_id = assay_run.plate_set_id AND assay_run.ID = _assay_run_id);


RETURN query
  SELECT temp1.plate_order,temp1.well, temp1.response, temp1.bkgrnd_sub, temp1.norm, temp1.norm_pos, temp1.p_enhance, temp1.well_type_id, temp1.replicates, temp1.target, temp2.sample_id FROM temp1 LEFT OUTER JOIN temp2 on (temp1.plate_order=temp2.plate_order AND temp1.well= temp2.by_col);

DROP TABLE temp1;
DROP TABLE temp2;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ginint4_consistent" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="ginint4_queryextract" returnType="internal" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="global_search" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
CREATE TEMP VIEW gsearch AS SELECT project_sys_name , '' AS "plate_set_sys_name",  'Project' AS "entity", project_sys_name AS "entity_sys_name" , project_name AS  entity_name , descr  FROM project
UNION
SELECT project.project_sys_name , plate_set.plate_set_sys_name , 'PlateSet' AS "entity",plate_set_sys_name AS "entity_sys_name" , plate_set_name AS "entity_name" , plate_set.descr FROM plate_set, project WHERE plate_set.project_id=project.ID      
UNION
SELECT project.project_sys_name , plate_set.plate_set_sys_name , 'Plate' AS "entity", plate_sys_name AS "entity_sys_name" , '' AS "entity_name" , plate.barcode AS descr FROM plate_set, project, plate, plate_plate_set WHERE plate_set.project_id=project.ID AND plate_plate_set.plate_set_id=plate_set.ID AND plate_plate_set.plate_id=plate.id       
UNION
SELECT project.project_sys_name , plate_set.plate_set_sys_name , 'Sample' AS "entity", sample_sys_name AS "entity_sys_name" , '' AS "entity_name" , sample.accs_id AS descr FROM plate_set, project, plate, plate_plate_set, well, well_sample, sample WHERE plate_set.project_id=project.ID AND plate_plate_set.plate_set_id=plate_set.ID AND plate_plate_set.plate_id=plate.ID AND well.plate_id=plate.ID AND well_sample.well_id=well.ID AND well_sample.sample_id=sample.id      
UNION
SELECT project.project_sys_name , plate_set.plate_set_sys_name , 'AssayRun' AS "entity", assay_run_sys_name AS "entity_sys_name" , assay_run_name AS "entity_name" ,  assay_run.descr AS descr FROM plate_set, project, assay_run WHERE plate_set.project_id=project.ID AND assay_run.plate_set_id=plate_set.ID      
UNION
SELECT project.project_sys_name , plate_set.plate_set_sys_name , 'HitList' AS "entity", hitlist_sys_name AS "entity_sys_name" , hitlist_name AS "entity_name" ,  hit_list.descr AS descr FROM plate_set, project, assay_run, hit_list WHERE plate_set.project_id=project.ID AND assay_run.plate_set_id=plate_set.ID AND hit_list.assay_run_id=assay_run.id;      


RETURN query
SELECT * FROM gsearch WHERE project_sys_name LIKE '%'|| _term || '%'
UNION
SELECT * FROM gsearch WHERE plate_set_sys_name LIKE '%'|| _term || '%'
UNION
SELECT * FROM gsearch WHERE entity LIKE '%'|| _term || '%'
UNION
SELECT * FROM gsearch WHERE entity_sys_name LIKE '%'|| _term || '%'
UNION
SELECT * FROM gsearch WHERE entity_name LIKE '%'|| _term || '%'
UNION
SELECT * FROM gsearch WHERE descr LIKE '%'|| _term || '%' ORDER BY project_sys_name, plate_set_sys_name, entity;

DROP VIEW gsearch;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="hmac" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="icount" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="idx" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="intarray_del_elem" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="intarray_push_array" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="intarray_push_elem" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="intset" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="intset_subtract" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="intset_union_elem" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_assay_run" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   v_id integer;
BEGIN
   
   INSERT INTO assay_run(assay_run_name , descr, assay_type_id, plate_set_id, plate_layout_name_id, lnsession_id)
   VALUES (_assay_run_name, _descr, _assay_type_id, _plate_set_id, _plate_layout_name_id, _lnsession_id)
   RETURNING id INTO v_id;

    UPDATE assay_run SET assay_run_sys_name = 'AR-'||v_id WHERE id=v_id;

RETURN v_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_hit_list" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
 hl_id INTEGER;
 hl_sys_name VARCHAR(10);
 s_id INTEGER;
BEGIN


  INSERT INTO hit_list(hitlist_name, descr, n, assay_run_id, lnsession_id)
   VALUES (_name, _descr, _num_hits, _assay_run_id, _lnsession_id)
   RETURNING id INTO hl_id;

    UPDATE hit_list SET hitlist_sys_name = 'HL-'|| hl_id WHERE id=hl_id;
    
FOR i IN 1.._num_hits loop
 INSERT INTO hit_sample(hitlist_id, sample_id)VALUES(hl_id, hit_list[i]);
END LOOP;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_plate" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   plt_id INTEGER;
   ps_id INTEGER = _plate_set_id;
   pf_id INTEGER;
   w_id INTEGER;
   s_id INTEGER;
   spl_include BOOLEAN := _include_sample;
   w integer;	

BEGIN

   INSERT INTO plate(plate_type_id,   plate_format_id, plate_layout_name_id)
   VALUES (_plate_type_id,  _plate_format_id, _plate_layout_name_id)
   RETURNING id  INTO plt_id;

    UPDATE plate SET plate_sys_name = 'PLT-'||plt_id WHERE id=plt_id;


FOR w IN 1.._plate_format_id LOOP

  --RAISE notice 'w: (%)', w;
       INSERT INTO well(by_col, plate_id) VALUES(w, plt_id)
       RETURNING id INTO w_id;
       
       IF spl_include THEN  --check if it is an \"unknown\" well i.e. not a control
       IF w IN (SELECT well_by_col  FROM plate_layout, plate_layout_name  WHERE plate_layout.plate_layout_name_id = plate_layout_name.id AND plate_layout.well_type_id = 1 AND plate_layout.plate_layout_name_id = _plate_layout_name_id) THEN
       INSERT INTO sample (sample_sys_name) VALUES (null)
       RETURNING id INTO s_id;
       UPDATE sample SET sample_sys_name = 'SPL-'||s_id WHERE id=s_id;

       INSERT INTO well_sample(well_id, sample_id)VALUES(w_id, s_id);
      END IF;
       END IF;
   END LOOP;

   INSERT INTO plate_plate_set(plate_set_id, plate_id)
   VALUES (ps_id, plt_id );

RETURN plt_id;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_plate_layout" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   src_id integer;
   dest_id INTEGER;
   dest_name VARCHAR(30);
BEGIN


   INSERT INTO plate_layout_name(name, descr, plate_format_id)
   VALUES (_plate_layout_name, _descr, _plate_format_id)
   RETURNING id INTO src_id;

dest_name := _plate_layout_name || '-dest';

   INSERT INTO plate_layout_name(name, descr, plate_format_id)
   VALUES (_plate_layout_name, _descr, _plate_format_id)
   RETURNING id INTO dest_id;

INSERT INTO layout_source_dest(src, dest) VALUES (src_id, dest_id);


 
RETURN plname_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_plate_set" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   ps_id INTEGER;
   n_plates INTEGER;
   p_type INTEGER;
   p_form INTEGER;
   prj_id INTEGER;
   plt_id INTEGER;
   play_n_id INTEGER;
   w_spls BOOLEAN := _with_samples;
   trg_lyt_name_id INTEGER := _target_layout_name_id;
BEGIN
   
   INSERT INTO plate_set(descr, plate_set_name, num_plates, plate_format_id, plate_type_id, project_id, plate_layout_name_id, lnsession_id, target_layout_name_id)
   VALUES (_descr, _plate_set_name, _num_plates, _plate_format_id, _plate_type_id, _project_id, _plate_layout_name_id, _lnsession_id, trg_lyt_name_id )
   RETURNING ID, plate_format_id, num_plates, project_id, plate_type_id, plate_layout_name_id INTO ps_id, p_form, n_plates, prj_id, p_type, play_n_id;
   UPDATE plate_set SET plate_set_sys_name = 'PS-'||ps_id WHERE id=ps_id;

FOR i IN 1..n_plates loop
	     -- _plate_type_id INTEGER, _plate_set_id INTEGER, _project_id INTEGER, _plate_format_id INTEGER, include_sample BOOLEAN
	    SELECT new_plate(p_type, ps_id, p_form, play_n_id, w_spls) INTO plt_id;
	    UPDATE plate_plate_set SET plate_order = i WHERE plate_set_id = ps_id AND plate_id = plt_id;

END LOOP;

RETURN ps_id;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_plate_set_from_group" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   ps_id INTEGER; 

BEGIN
  

   INSERT INTO plate_set(descr, plate_set_name, num_plates, plate_format_id, plate_type_id, project_id, plate_layout_name_id, lnsession_id)
   VALUES (_descr, _plate_set_name, _num_plates, _plate_format_id, _plate_type_id, _project_id, _plate_layout_name_id, _lnsession_id )
   RETURNING id INTO ps_id;
   UPDATE plate_set SET plate_set_sys_name = 'PS-'||ps_id WHERE id=ps_id;


RETURN ps_id;


END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_project" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   v_id integer;
BEGIN
   INSERT INTO project(descr, project_name, lnsession_id)
   VALUES (_descr, _project_name, _lnsession_id)
   RETURNING id INTO v_id;
   UPDATE project SET project_sys_name = 'PRJ-'||v_id WHERE id=v_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_sample" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   v_id integer;
BEGIN
   
   INSERT INTO sample(project_id, plate_id, accs_id)
   VALUES (_project_id, _plate_id,   _accs_id)
   RETURNING id INTO v_id;

    UPDATE sample SET sample_sys_name = 'SPL-'||v_id WHERE id=v_id RETURNING id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_target" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   v_id integer;
BEGIN
   
   INSERT INTO target(project_id, target_name, descr, accs_id)
   VALUES (_project_id, _trg_name, _descr,   _accs_id)
   RETURNING id INTO v_id;

    UPDATE target SET target_sys_name = 'TRG-'||v_id WHERE id=v_id;

RETURN v_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_target_layout_name" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   v_id integer;
BEGIN  
   INSERT INTO target_layout_name(project_id,  target_layout_name_name, target_layout_name_desc, reps)
   VALUES (_project_id,  _trg_lyt_name, _descr, _reps)
   RETURNING id INTO v_id;

    UPDATE target_layout_name SET target_layout_name_sys_name = 'TLY-'||v_id WHERE id=v_id;

    INSERT INTO target_layout(target_layout_name_id, target_id, quad) VALUES (v_id, q1_id, 1),
    (v_id, q2_id, 2),(v_id, q3_id, 3),(v_id, q4_id, 4);

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="new_user" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
BEGIN
   INSERT INTO lnuser(usergroup_id, lnuser_name, tags, password)
   VALUES (_group_id, _name, _tags, _password);
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_armor_headers" returnType="SETOF record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_key_id" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_pub_decrypt_bytea" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_pub_encrypt" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_pub_encrypt_bytea" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_sym_decrypt" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="pgp_sym_decrypt_bytea" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_sym_encrypt" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pgp_sym_encrypt_bytea" returnType="bytea" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="populate_assay_run_stats" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE

format_id INTEGER; 
max_response DECIMAL;
min_response DECIMAL;
mean_bkgrnd DECIMAL;
std_dev_bkgrnd DECIMAL;
mean_pos DECIMAL;
stdev_pos DECIMAL;
mean_neg DECIMAL;
stdev_neg DECIMAL;
mean_neg_3_sd DECIMAL;
mean_neg_2_sd DECIMAL;
mean_pos_3_sd DECIMAL;
mean_pos_2_sd DECIMAL;
   


BEGIN
select plate_format_id from plate_layout_name where plate_layout_name.id = (select plate_layout_name_id from assay_run where assay_run.id = _assay_run_id) INTO format_id;

DROP TABLE IF EXISTS data;
CREATE TEMPORARY TABLE data AS (select * from get_scatter_plot_data( _assay_run_id )); 

DROP TABLE IF EXISTS assay_run_processed;
CREATE TEMPORARY TABLE assay_run_processed AS select MAX(plate) AS "plate", MAX(well) AS "well", avg(response) AS "response" , avg(bkgrnd_sub) AS "bkgrnd_sub" , avg(norm) AS "norm" , avg(norm_pos) AS "norm_pos" , avg(p_enhance) AS "p_enhance" , max(well_type_id) AS "well_type_id" , max(replicates) AS "replicates" , max(target) AS "target" , max(sample_id) AS "sample_id" , max(parent_well) AS "parent_well"  FROM data LEFT JOIN well_numbers ON (data.well = well_numbers.by_col) where well_numbers.plate_format = format_id GROUP BY parent_well,replicates, target, plate;

DROP TABLE IF EXISTS with_samples;
CREATE TEMPORARY TABLE with_samples AS (select * from assay_run_processed where well_type_id = 1 AND sample_id is not null ) ;

DROP TABLE IF EXISTS positives;
CREATE TEMPORARY TABLE positives AS (select * from assay_run_processed where well_type_id = 2 );

DROP TABLE IF EXISTS negatives;
CREATE TEMPORARY TABLE negatives AS (select * from assay_run_processed where well_type_id = 3 );

DROP TABLE IF EXISTS backgrounds;
CREATE TEMPORARY TABLE backgrounds AS (select * from assay_run_processed where well_type_id = 4 );


-- background subtracted

select max(bkgrnd_sub) from with_samples INTO max_response;
select min(bkgrnd_sub) from with_samples INTO min_response;
select avg(bkgrnd_sub) from with_samples INTO mean_bkgrnd;
select stddev_samp(bkgrnd_sub) from with_samples INTO std_dev_bkgrnd;
select avg(bkgrnd_sub) from positives INTO mean_pos;
select stddev_samp(bkgrnd_sub) from positives INTO stdev_pos;
select avg(bkgrnd_sub) from negatives INTO mean_neg;
select stddev_samp(bkgrnd_sub) from negatives INTO stdev_neg;
mean_neg_3_sd := mean_neg + 3*stdev_neg;
mean_neg_2_sd := mean_neg + 2*stdev_neg;
mean_pos_3_sd := mean_pos + 3*stdev_pos;
mean_pos_2_sd := mean_pos + 2*stdev_pos;

-- public static final int RAW = 0;
-- public static final int NORM = 1;
-- public static final int NORM_POS = 2;
-- public static final int P_ENHANCE = 3;
 

INSERT INTO assay_run_stats ( assay_run_id, response_type, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos, mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd ) VALUES ( _assay_run_id, 0, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos,mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd );

-- norm

select max(norm) from with_samples INTO max_response;
select min(norm) from with_samples INTO min_response;
select avg(norm) from with_samples INTO mean_bkgrnd;
select stddev_samp(norm) from with_samples INTO std_dev_bkgrnd;
select avg(norm) from positives INTO mean_pos;
select stddev_samp(norm) from positives INTO stdev_pos;
select avg(norm) from negatives INTO mean_neg;
select stddev_samp(norm) from negatives INTO stdev_neg;
mean_neg_3_sd := mean_neg + 3*stdev_neg;
mean_neg_2_sd := mean_neg + 2*stdev_neg;
mean_pos_3_sd := mean_pos + 3*stdev_pos;
mean_pos_2_sd := mean_pos + 2*stdev_pos;

INSERT INTO assay_run_stats ( assay_run_id, response_type, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos, mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd ) VALUES ( _assay_run_id, 1, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos,mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd );


-- norm_pos

select max(norm_pos) from with_samples INTO max_response;
select min(norm_pos) from with_samples INTO min_response;
select avg(norm_pos) from with_samples INTO mean_bkgrnd;
select stddev_samp(norm_pos) from with_samples INTO std_dev_bkgrnd;
select avg(norm_pos) from positives INTO mean_pos;
select stddev_samp(norm_pos) from positives INTO stdev_pos;
select avg(norm_pos) from negatives INTO mean_neg;
select stddev_samp(norm_pos) from negatives INTO stdev_neg;
mean_neg_3_sd := mean_neg + 3*stdev_neg;
mean_neg_2_sd := mean_neg + 2*stdev_neg;
mean_pos_3_sd := mean_pos + 3*stdev_pos;
mean_pos_2_sd := mean_pos + 2*stdev_pos;

INSERT INTO assay_run_stats ( assay_run_id, response_type, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos, mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd ) VALUES ( _assay_run_id, 2, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos,mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd );

-- p_enhance

select max(p_enhance) from with_samples INTO max_response;
select min(p_enhance) from with_samples INTO min_response;
select avg(p_enhance) from with_samples INTO mean_bkgrnd;
select stddev_samp(p_enhance) from with_samples INTO std_dev_bkgrnd;
select avg(p_enhance) from positives INTO mean_pos;
select stddev_samp(p_enhance) from positives INTO stdev_pos;
select avg(p_enhance) from negatives INTO mean_neg;
select stddev_samp(p_enhance) from negatives INTO stdev_neg;
mean_neg_3_sd := mean_neg + 3*stdev_neg;
mean_neg_2_sd := mean_neg + 2*stdev_neg;
mean_pos_3_sd := mean_pos + 3*stdev_pos;
mean_pos_2_sd := mean_pos + 2*stdev_pos;

INSERT INTO assay_run_stats ( assay_run_id, response_type, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos, mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd ) VALUES ( _assay_run_id, 3, max_response, min_response, mean_bkgrnd, std_dev_bkgrnd, mean_pos, stdev_pos,mean_neg_3_sd, mean_neg_2_sd, mean_pos_3_sd, mean_pos_2_sd );


DROP TABLE IF EXISTS data;
DROP TABLE IF EXISTS assay_run_processed;

DROP TABLE IF EXISTS with_samples;
DROP TABLE IF EXISTS positives;
DROP TABLE IF EXISTS negatives;
DROP TABLE IF EXISTS backgrounds;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="process_access_ids" returnType="SETOF temp_accs_id" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  r temp_accs_id%rowtype;
BEGIN

TRUNCATE temp_accs_id RESTART IDENTITY CASCADE;

execute sql_statement;


   FOR r IN
      SELECT * FROM temp_accs_id
   loop

UPDATE sample SET accs_id = r.accs_id WHERE sample.ID IN ( SELECT sample.id FROM plate_set, plate_plate_set, plate, well, well_sample, sample WHERE plate_plate_set.plate_set_id=ps_id AND plate_plate_set.plate_id=plate.id AND well.plate_id=plate.ID AND well_sample.well_id=well.ID AND well_sample.sample_id=sample.ID AND plate_plate_set.plate_order=r.plate_order AND well.by_col=r.by_col);


       RETURN NEXT r;
   END LOOP;

TRUNCATE temp_accs_id RESTART IDENTITY CASCADE;

END;

]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="process_assay_run_data" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   plates INTEGER[]; 
   wells INTEGER[];  
   background decimal;
   positives decimal;
   negatives DECIMAL;
   unk_max DECIMAL;
   norm_factor DECIMAL;
--   format INTEGER;
BEGIN


CREATE TABLE data_set AS
SELECT max(assay_result_pre.assay_run_id) as assay_run_id, assay_result_pre.plate_order, max(assay_result_pre.well) as well, avg( assay_result_pre.response) as response, 0.0 AS bkgrnd_sub, 0.0 AS norm, 0.0 AS norm_pos,0.0 AS p_enhance,  max(plate_layout.well_by_col) AS well_by_col, max(plate_layout.well_type_id) AS well_type_id, plate_layout.replicates, plate_layout.target, max(assay_run.plate_layout_name_id) AS plate_layout_name_id, well_numbers.parent_well
FROM assay_result_pre, assay_run, plate_layout, plate_layout_name, well_numbers
WHERE  assay_result_pre.well = plate_layout.well_by_col AND 
       assay_result_pre.assay_run_id = assay_run.id AND  
       well_numbers.by_col = plate_layout.well_by_col AND
       well_numbers.plate_format=plate_layout_name.plate_format_id AND
       assay_run.plate_layout_name_id=plate_layout_name.id AND
       plate_layout.plate_layout_name_id = assay_run.plate_layout_name_id  AND 
       assay_run.ID = _assay_run_id::INTEGER
GROUP BY well_numbers.parent_well, plate_layout.replicates, plate_layout.target, assay_result_pre.plate_order
ORDER BY plate_order, parent_well;

-- background subtract

SELECT ARRAY (SELECT distinct plate_order FROM data_set WHERE data_set.assay_run_id = _assay_run_id  ORDER BY plate_order) INTO plates;

FOR plate_var IN 1..array_length(plates,1) LOOP
  SELECT AVG(data_set.response) FROM data_set WHERE data_set.plate_order = plate_var AND data_set.well_type_id=4 INTO background;
  SELECT ARRAY (SELECT distinct well FROM data_set WHERE plate_order=plate_var ORDER BY well) INTO wells;

  FOR well_var IN 1..array_length(wells,1) LOOP

          UPDATE data_set SET bkgrnd_sub  = GREATEST( (data_set.response-background), 0) WHERE assay_run_id = _assay_run_id AND plate_order=plate_var AND well = wells[well_var];
-- raise notice 'well: %; plate %', wells[well_var], plate_var;

   END LOOP;

END LOOP;

-- use background subtracted values

FOR plate_var IN 1..array_length(plates,1) LOOP

SELECT AVG(data_set.bkgrnd_sub) FROM data_set WHERE data_set.plate_order = plate_var AND data_set.well_type_id=2 INTO positives;
SELECT AVG(data_set.bkgrnd_sub) FROM data_set WHERE data_set.plate_order = plate_var AND data_set.well_type_id=3 INTO negatives;
SELECT MAX(data_set.bkgrnd_sub) FROM data_set WHERE data_set.plate_order = plate_var AND data_set.well_type_id=1 INTO unk_max;
raise notice 'plate %; unk_max: %', plate_var, unk_max;

SELECT ARRAY (SELECT distinct well FROM data_set WHERE plate_order=plate_var ORDER BY well) INTO wells;

       FOR well_var IN 1..array_length(wells,1) LOOP

          UPDATE data_set SET  norm = (data_set.bkgrnd_sub/unk_max), norm_pos = (data_set.bkgrnd_sub/positives), p_enhance = 100*(((data_set.bkgrnd_sub-negatives)/(positives-negatives))-1) WHERE assay_run_id = _assay_run_id AND plate_order=plate_var AND well = wells[well_var];
   END LOOP;

END LOOP;


INSERT INTO assay_result SELECT assay_run_id, plate_order, well, response , bkgrnd_sub::REAL, norm::REAL, norm_pos::REAL, p_enhance::REAL from data_set;
 DROP TABLE IF EXISTS data_set;
 TRUNCATE TABLE assay_result_pre;

PERFORM populate_assay_run_stats(_assay_run_id);


END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="process_barcode_ids" returnType="SETOF temp_barcode_id" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
  r temp_barcode_id%rowtype;
BEGIN

TRUNCATE temp_barcode_id RESTART IDENTITY CASCADE;
--raise NOTice 'sql: (%)', sql_statement;
execute sql_statement;
--raise NOTice 'post execute: (%)', 2;
   FOR r IN
      SELECT * FROM temp_barcode_id
   loop

UPDATE plate SET barcode = r.barcode_id WHERE plate.ID IN ( SELECT plate.id FROM plate_set, plate_plate_set, plate  WHERE plate_plate_set.plate_set_id=ps_id AND plate_plate_set.plate_id=plate.id  AND plate_plate_set.plate_order=r.plate_order);

       RETURN NEXT r;
   END LOOP;

TRUNCATE temp_barcode_id RESTART IDENTITY CASCADE;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="querytree" returnType="text" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="rboolop" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment><![CDATA[boolean operation with array]]></comment>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="rearray_transfer_samples" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE
   i INTEGER;
all_hit_sample_ids INTEGER[];
dest_wells INTEGER[];
num_hits INTEGER;
rp_id INTEGER;


BEGIN
--select get in plate, well order, not necessarily sample order 
SELECT ARRAY (SELECT  sample.id FROM plate_set, plate_plate_set, plate, well, well_sample, sample WHERE plate_plate_set.plate_set_id=plate_set.ID AND plate_plate_set.plate_id=plate.id AND well.plate_id=plate.ID AND well_sample.well_id=well.ID AND well_sample.sample_id=sample.ID and plate_set.id=source_plate_set_id AND sample.ID  IN  (SELECT hit_sample.sample_id FROM hit_sample WHERE hit_sample.hitlist_id = hit_list_id) ORDER BY plate.ID, well.ID) INTO all_hit_sample_ids;

num_hits := array_length(all_hit_sample_ids, 1);
--raise NOTice 'num_hits: (%)', num_hits;

SELECT ARRAY (SELECT well.ID FROM plate_set, plate_plate_set, plate, well, plate_layout WHERE plate_plate_set.plate_set_id=plate_set.ID AND plate_plate_set.plate_id=plate.id AND well.plate_id=plate.ID AND plate_set.plate_layout_name_id=plate_layout.plate_layout_name_id AND plate_layout.well_by_col= well.by_col AND plate_set.id=dest_plate_set_id AND plate_layout.well_type_id=1 ORDER BY well.ID) INTO dest_wells;


  for i IN 1..num_hits
  loop
  INSERT INTO well_sample (well_id, sample_id) VALUES ( dest_wells[i], all_hit_sample_ids[i]);   
raise NOTice 'dest_well: (%)', dest_wells[i];
raise NOTice 'sample: (%)', all_hit_sample_ids[i];


END LOOP;

INSERT INTO rearray_pairs (src, dest) VALUES (source_plate_set_id, dest_plate_set_id)  returning id INTO rp_id;

CREATE TEMP TABLE temp1 (plate_sys_name VARCHAR(10), by_col INTEGER, sample_id INTEGER);

INSERT INTO temp1 SELECT  plate.plate_sys_name, well.by_col, sample.ID AS "sample_id"  FROM plate_set, plate_plate_set, plate, well, well_sample, sample  WHERE plate_plate_set.plate_set_id=plate_set.ID AND plate_plate_set.plate_id=plate.id AND well.plate_id=plate.ID AND well_sample.well_id=well.ID AND well_sample.sample_id=sample.ID and plate_set.id=source_plate_set_id  AND sample.ID IN  (SELECT hit_sample.sample_id FROM hit_sample WHERE hit_sample.hitlist_id = hit_list_id ORDER BY sample.ID);

CREATE TEMP TABLE temp2 (plate_sys_name VARCHAR(10), by_col INTEGER, sample_id INTEGER);

INSERT INTO temp2 SELECT  plate.plate_sys_name, well.by_col, sample.ID AS "sample_id" FROM plate_set, plate_plate_set, plate, well, well_sample, sample  WHERE plate_plate_set.plate_set_id=plate_set.ID AND plate_plate_set.plate_id=plate.id AND well.plate_id=plate.ID AND well_sample.well_id=well.ID AND well_sample.sample_id=sample.ID and plate_set.id=dest_plate_set_id  ORDER BY sample.ID;

INSERT INTO worklists ( rearray_pairs_id, sample_id, source_plate, source_well, dest_plate, dest_well) SELECT rp_id, temp1.sample_id, temp1.plate_sys_name, temp1.by_col, temp2.plate_sys_name, temp2.by_col FROM temp1, temp2 WHERE temp1.sample_id = temp2.sample_id;

DROP TABLE temp1, temp2;

END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="reformat_plate_set" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="PLPGSQL"><![CDATA[
DECLARE

dest_plate_set_id INTEGER;
all_source_well_ids INTEGER[];
all_dest_well_ids INTEGER[];
w INTEGER;
holder INTEGER;

BEGIN
--here I am creating the destination plate set, no samples included
SELECT new_plate_set(dest_descr ,dest_plate_set_name, dest_num_plates, dest_plate_format_id, dest_plate_type_id, project_id, dest_plate_layout_name_id, lnsession_id, false, target_layout_name_id) INTO dest_plate_set_id;

--RAISE notice 'dest_plate_set_id: (%)', dest_plate_set_id;

CREATE TEMP TABLE temp1(counter INT, plate_id INT, plate_order INT, well_by_col INT, well_id INT);

FOR i IN 1..n_reps_source LOOP
INSERT INTO temp1 select i, well.plate_id, plate_plate_set.plate_order, well.by_col, well.id AS well_id FROM plate_plate_set, well  WHERE plate_plate_set.plate_set_id = source_plate_set_id AND plate_plate_set.plate_id = well.plate_id   ORDER BY well.plate_id, well.ID;
END LOOP;

SELECT ARRAY (SELECT well_id FROM temp1 ORDER BY plate_id, counter, well_id) INTO all_source_well_ids;


SELECT ARRAY (SELECT  dest.id  FROM ( SELECT plate_plate_set.plate_ID, well.by_col,  well.id  FROM well, plate_plate_set  WHERE plate_plate_set.plate_set_id = dest_plate_set_id  AND plate_plate_set.plate_id = well.plate_id) AS dest JOIN (SELECT well_numbers.well_name, well_numbers.by_col, well_numbers.quad FROM well_numbers WHERE well_numbers.plate_format=dest_plate_format_id)  AS foo ON (dest.by_col=foo.by_col) ORDER BY plate_id, quad, dest.by_col) INTO all_dest_well_ids;


FOR w IN 1..array_length(all_source_well_ids,1)  LOOP
SELECT sample.id FROM sample, well, well_sample WHERE well_sample.well_id=well.id AND well_sample.sample_id=sample.id AND well.id= all_source_well_ids[w] INTO holder;
INSERT INTO well_sample (well_id, sample_id) VALUES (all_dest_well_ids[w], holder );


--RAISE notice  'w: (%)', w;
--RAISE notice  'all_source_well_ids[w]: (%)', all_source_well_ids[w];
--RAISE notice  'all_dest_well_ids[w]: (%)', all_dest_well_ids[w];

END LOOP;

--RAISE notice  'all_source_well_ids: (%)', all_source_well_ids;
--RAISE notice  'all_dest_well_ids: (%)', all_dest_well_ids;


DROP TABLE temp1;

RETURN dest_plate_set_id;
END;
]]></definition>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="sort" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="sort_asc" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="sort_desc" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="subarray" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="uniq" returnType="ARRAY" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="C"/>
      </routine>
   </routines>
</database>
